## 性能指标

在比较算法时，我们使用了问题数据的规模n来评估算法的性能。这是过去半个世纪算法比较的标准方法。通过输入数据的规模评估算法的执行时间，我们可以知晓哪种算法能够更好地适应一些异常规模的问题。性能评估的第二种方法是考虑算法将会耗费多少内存或者存储空间。
常见的算法分类(按照效率降序排列)如下:

- 常数级: O(1) 
- 对数级: O(log n)
- 次线性级: O(n^d), 其中d< 1
- 线性级: O(n)
- 线性对数级: O(n log n)
- 平方级: O(n)
- 指数级: O(2^n)

注意: 在评估算法性能时，必须要找到算法中计算费用最大的部分才能决定算法的分类。
例如，如果一个算法可以被划分为两个任务，其中一个任务为线性级， 另一个任务为平方级，那么这个算法的总体性能应当归为平方级。

## 基本的数据结构的查找，插入，删除，遍历的时间复杂度
数据结构 | 查找 | 插入 | 删除 | 遍历
---|---|---|---|---
数组 | O(N) | O(1) | O(N) |--
有序数组 | O(logN) | O(N) | O(N) | O(N)
链表 | O(N) |O(1) | O(N) |--
有序链表 | O(N) | O(N) | O(N) | O(N)
二叉树(一般情况) | O(logN) | O(logN) | O(logN) | O(N)
二叉树(最坏情况) | O(N) | O(N) | O(N) | O(N)
平衡树(一般情况和最坏情况) |  O(logN) | O(logN) |  O(logN) | O(N)
哈希表 | O(1) | O(1) | O(1) | --


结点的总数量是n，二叉树最坏的情况是整个二叉排序树往右倾斜(或者左倾斜)，成了单向链表，所以最坏情况查找复杂度是O(N)。


## 算法时间复杂度

排序方法 |	时间复杂度(平均)| 	时间复杂度(最坏) |	时间复杂度(最好)| 	空间复杂度| 	稳定性| 	复杂性
---|---|---|---|---|---|---
直接插入排序 | 	O(n^2)|  O(n^2)|  O(n)|  O(1) | 稳定|  	简单| 
希尔排序|  	O(nlogn) | 	O(n^2) | 	O(n^1.3)|  	O(1) | 	不稳定|  	较复杂| 
直接选择排序 | 	O(n^2)|  	O(n^2)|  	O(n^2)|  	O(1) | 	不稳定|  	简单| 
堆排序|  O(nlogn)| 	O(nlogn)| O(nlogn) | O(1)| 	不稳定 | 	较复杂| 
冒泡排序 | 	O(n^2)|  	O(n^2)|  	O(n)|  	O(1) | 	稳定| 	简单| 
快速排序|  	O(nlogn) | 	O(n^2) | 	O(nlogn) | 	O(logn) | 	不稳定 | 	较复杂| 
归并排序 | 	O(nlogn) | 	O(nlogn) | 	O(nlogn) 	| O(n) 	| 稳定| 较复杂| 
基数排序 | 	O(d(n+r)) | 	O(d(n+r))|  	O(d(n+r)) | 	O(n+r) 	| 稳定| 	较复杂| 


## 选择排序算法的标准

前提条件 | 排序算法
--- | ---
只有少量的元素 | 插入排序
元素几乎已经排好序 | 插入排序
关注最坏情况下的性能 | 堆排序
力求在平均情况下具有良好性能 | 快速排序
元素来自于均匀密集分布的数据源 | 桶排序
尽可能地少写代码 | 插入排序
要求稳定排序 | 归并排序

