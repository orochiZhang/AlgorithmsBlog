## TCP
1. **面向连接**：TCP接收方与发送方维持了一个状态（三次握手建立连接，四次挥手断开连接），双方都知道对方的存在。    
2. **可靠的**：发送出去的数据对方一定能够接收到，丢包超时会重传，网络层的包是不能保证顺序的，使用TCP是可以保证按照发送的顺序收到的。   
3. **面向字节流**
4. **流量控制与拥塞控制**：TCP靠谱通过滑动窗口确保，发送的数据接收方来得及收。TCP无私，发生数据包丢失的时候认为整个网络比较堵，自己放慢数据发送速度。    
5. **只支持一对一**：每一条TCP连接只能是点对点的

## UDP
1. 无连接。
2. 尽最大努力交付；
3. 面向报文
4. 无拥塞控制；
5. 支持一对一、一对多、多对一和多对多的交互通信
6. 首部开销小

## TCP字节流与UDP数据报
客户端通过TCP连接给服务端发送数据，客户端只调用了一次 write，发送了100个字节，但是服务端可以分10次收完，每次10个字节。
也可以调用10次write，每次发10个字节，但是对方可以一次就收完。
假设数据都能到达的情况下，发送的数据量不能大于对方的接收缓存(流量控制)，
如果你硬是要发送过量数据，则对方的缓存满了就会把多出的数据丢弃。

UDP和TCP不同，发送端调用了几次write，接收端必须用相同次数的read读完。
UPD是基于报文的，在接收的时候，每次最多只能读取一个报文，报文和报文是不会合并的，如果缓冲区小于报文长度，则多出的部分会被丢弃。
也就说，如果不指定MSG_PEEK标志，每次读取操作将消耗一个报文。

其实，这种不同是由TCP和UDP的特性决定的。
TCP是面向连接的，也就是说，在连接持续的过程中，socket中收到的数据都是由同一台主机发出的(劫持什么的不考虑)。
因此，知道保证数据是有序的到达就行了，至于每次读取多少数据自己看着办。

而UDP是无连接的协议，也就是说，只要知道接收端的IP和端口，且网络是可达的，任何主机都可以向接收端发送数据。
这时候，如果一次能读取超过一个报文的数据，则会乱套。
比如，主机A向发送了报文P1，主机B发送了报文P2，如果能够读取超过一个报文的数据，那么就会将P1和P2的数据合并在了一起，这样的数据是没有意义的。

## 端口复用
TCP/UDP 使用一个五元组来定位一个连接: src_ip, src_port, dest_ip, dest_port, protocol_type
1. 服务器的IP
2. 服务器的Port
3. 客户端的IP
4. 客户端的Port
5. 协议
- 只要五个元素的组合中有一个元素是不一样，那就可以区别不同的连接，这就是为什么一个端口监听可以建立多个socket连接的原理。
- 同一个端口号和IP地址上可以同时绑定一个TCP套接字和一个UDP套接字。因为协议不一样，所以端口监听是完全独立的。


## 其他
**【问题】QQ 为什么以 UDP 协议为主，以 TCP 协议为辅？**

答案转载自知乎https://www.zhihu.com/question/20292749

--- 

某次架构师大会上那个58同城做即时通信的人说:原因是因为当时没有epoll这种可以支持成千上万tcp并发连接的技术,所以他们使用了udp,然后在udp上面封装了一下,模拟了一下tcp,解决了大并发的问题,之后因为做的很nb了,虽然epoll这种技术出现了,还是没有改回使用tcp了.现在再做类似的东西就不需要使用udp了.

这个说法应该比较可信的.

---

很多人提到keepalive，TCP无法感知网络中断这些问题。。。这个算是TCP一个容易踩的坑，但这并不能说明UDP就比TCP好（或者说解释为何要使用UDP）。因为在UDP上面一样需要面对这些问题，而解决这类问题的方法和在TCP上面进行应用层心跳的方法其实没有本质上的区别。而这就是为什么没有接触过这类问题的人会有题主提出的疑惑。

那么为什么呢？最本质上UDP的优势还是带宽的利用。这一切要回归到99~03年的网络状况，当时网络的特点就是接入带宽很窄而且抖动特别厉害。所谓抖动可能是多方面的，例如延时突发性地暴增、也有可能是由于路由层面的变化突然导致路由黑洞，还各种等等等等的问题。TCP因为拥塞控制、保证有序等原因，在这种网络状态上对带宽的利用是非常低的。而且因为网络抖动的原因，应用层心跳超时（一般不依靠keepalive）应用层主动断掉socket之后TCP需要三次握手才能重新建立链接，一旦出现频繁的小抖动就会使得带宽利用更低。而等待四次挥手的时间，也会占用服务器上宝贵的资源。

**总结来说，当网络差到一定程度了，TCP的优势反而会成为劣势。**

这时候我们再看看UDP在这种情况下的表现。使用UDP对抗网络抖动，说到底就是在应用层比TCP更快地探测和重传，一旦超过一定的时间没有收到回复，客户端可以选择马上重试或者换一个IP:PORT重试（假如你的服务像QQ一样有多个接入），在服务器端则可以果断地断掉socket。而可以应用UDP的时候，往往是你的应用层协议本身已经具备了一定的面向连接的特性。如果你应用层的协议已经达到了一定程度的消息幂等，客户端可以几乎无脑地进行重传，这样就可以尽可能地降低网络抖动的影响，同时也可以尽可能地利用整个带宽。而刚好QQ的协议，就具备类似的特点。

简单来说就是我们可以使用UDP实现一个面向连接协议，这个协议可以很好地适应当时的网络状况和QQ本身的业务。但凡事都有成本，成本就是你的应用层协议本身需要去实现抵抗网络异常带来的问题。例如乱序、例如业务数据的分片和重组、例如网络状态探测等等等等。。。

而现在UDP也应用在很多跨运营商、跨地域、跨机房之间的服务调用当中。原因无它，就是网络烂到一定程度了。

## 参考文献
- [理解端口复用](https://blog.csdn.net/dlf1769/article/details/78786775)
