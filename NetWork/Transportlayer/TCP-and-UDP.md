## TCP
1. **面向连接**：TCP接收方与发送方维持了一个状态（三次握手建立连接，四次挥手断开连接），双方都知道对方的存在。    
2. **可靠的**：发送出去的数据对方一定能够接收到，丢包超时会重传，网络层的包是不能保证顺序的，使用TCP是可以保证按照发送的顺序收到的。   
3. **面向字节流**
4. **流量控制与拥塞控制**：TCP靠谱通过滑动窗口确保，发送的数据接收方来得及收。TCP无私，发生数据包丢失的时候认为整个网络比较堵，自己放慢数据发送速度。    
5. **只支持一对一**：每一条TCP连接只能是点对点的

## UDP
1. 无连接。
2. 尽最大努力交付；
3. 面向报文
4. 无拥塞控制；
5. 支持一对一、一对多、多对一和多对多的交互通信
6. 首部开销小

## TCP字节流与UDP数据报
客户端通过TCP连接给服务端发送数据，客户端只调用了一次 write，发送了100个字节，但是服务端可以分10次收完，每次10个字节。
也可以调用10次write，每次发10个字节，但是对方可以一次就收完。
假设数据都能到达的情况下，发送的数据量不能大于对方的接收缓存(流量控制)，
如果你硬是要发送过量数据，则对方的缓存满了就会把多出的数据丢弃。

UDP和TCP不同，发送端调用了几次write，接收端必须用相同次数的read读完。
UPD是基于报文的，在接收的时候，每次最多只能读取一个报文，报文和报文是不会合并的，如果缓冲区小于报文长度，则多出的部分会被丢弃。
也就说，如果不指定MSG_PEEK标志，每次读取操作将消耗一个报文。

其实，这种不同是由TCP和UDP的特性决定的。
TCP是面向连接的，也就是说，在连接持续的过程中，socket中收到的数据都是由同一台主机发出的(劫持什么的不考虑)。
因此，知道保证数据是有序的到达就行了，至于每次读取多少数据自己看着办。

而UDP是无连接的协议，也就是说，只要知道接收端的IP和端口，且网络是可达的，任何主机都可以向接收端发送数据。
这时候，如果一次能读取超过一个报文的数据，则会乱套。
比如，主机A向发送了报文P1，主机B发送了报文P2，如果能够读取超过一个报文的数据，那么就会将P1和P2的数据合并在了一起，这样的数据是没有意义的。

## 端口复用
TCP/UDP 使用一个五元组来定位一个连接: src_ip, src_port, dest_ip, dest_port, protocol_type
1. 服务器的IP
2. 服务器的Port
3. 客户端的IP
4. 客户端的Port
5. 协议
- 只要五个元素的组合中有一个元素是不一样，那就可以区别不同的连接，这就是为什么一个端口监听可以建立多个socket连接的原理。
- 同一个端口号和IP地址上可以同时绑定一个TCP套接字和一个UDP套接字。因为协议不一样，所以端口监听是完全独立的。



## 参考文献
- [理解端口复用](https://blog.csdn.net/dlf1769/article/details/78786775)
